# Introduction #

Add your content here.

# Build Source Code #

Library is written on c++ using ATL and WTL 8.0. To build source code you need Microsoft Visual Studio 2008.


# Required headers and binaries #

To build your application you need following headers:
  * ImageShackAPI.h
  * ImageShackBase.h
  * uploader/Uploader.h
  * uploader/templates.h
  * uploader/stubs.h
  * uploader/safe.h
  * templates/SmartPtr.h
  * WTL 8.0
  * ImageShackAPI.lib
  * ImageShackAPI.dll

# Library description #

> Classes and structures are placed to _API::ImageShack_ namespace.

> _UploadInfo_ structure contains upload parameters:
```
struct UploadInfo
{
    /**
     * Full path to image or video file.
     * If This parameter is HTTP URL than transload method is used instead of upload.
     */
    CStringW file;

    /**
     * Optional, content-type of file.
     */
    CStringW content_type;

    /**
     * Full path to video default frame picture. Optional, used only for video upload.
     * When you uploading your video you could supply a default frame
     * that will be displayed when video is stopped.
     * Dimensions of this image should be the same as video file's ones to avoid artefacts on screen. 
     */
    CStringW thumbnail;

    /**
     * Optional, resize options for image in form WxH if image is uploaded/transloaded.
     * No impact on video uploads. 
     *
     * See SetSize(W, H) method.
     */
    CStringW size;

    /**
     * Optional, a comma-separated list of tags to add to your video/image. E.g. family,picture.
     */
    CStringW tags;

    /**
     * Developer could tell to ImageShack to leave/remove information bar on thumbnail image generated by ImageShack.
     * Default is false.
     */
    bool remove_bar;

    /**
     * Public/private marker of your video/picture.
     * Default is true.
     */
    bool is_public;
}
```
> _IUserInfo_ interface contains information about logged user:
```
class IUserInfo
{
public:
    /** Returns user id */
    virtual LPCWSTR GetId() const = 0;
    /** Returns user name (can be NULL). */
    virtual LPCWSTR GetName() const = 0;
    /** Returns user cookie */
    virtual LPCWSTR GetCookie() const = 0;
};
```
> _ErrorResponse_ structure is used to obtain login error description:
```
struct ErrorResponse
{
    CStringW code;
    CStringW message;
};
```

> Class _ImageShackAPI_ implements base functionality to login and upload/transload items:
```
class ImageShackAPI
{
public:
    /**
     * ImageShackAPI constructor.
     *
     * Parameters:
     *   pszDevKey - The key is a string which identifies your application.
     *               See http://code.google.com/p/imageshackapi/wiki/DeveloperKey
     */
    ImageShackAPI(const char* pszDevKey);

    /**
     * Login to ImageShack.
     * After successful login use GetUserInfo() to get user information.
     * This method will reset any parameters which were set manually using SetCookie() or SetAuthInfo()
     *
     * Parameters:
     *   pszUserName - username or email.
     *   pszPassword - user password.
     *   pError      - optional, if login failed and parameter is not NULL it will be filled with error description and code.
     */
    bool Login(LPCWSTR pszUserName, LPCWSTR pszPassword, /*out*/ ErrorResponse* pError = NULL);

    /**
     * Open Login dialog and call Login(pszUserName, pszPassword). Read description above.
     */
    bool Login();

    /**
     * Check whether user is logged in.
     * Method returns false if you use SetCookie() or SetAuthInfo() instead of Login().
     */
    bool IsLoggedIn() const;

    /**
     * Return id and cookie of the logged in user.
     * See IUserInfo above.
     */
    IUserInfo* GetUserInfo() const; 

    /**
     * Reset username/password and cookie which were set by Login(), SetCookie() and SetAuthInfo().
     */
    void Logout();

    /**
     * Set cookie without login.
     * After successful login you can save cookie (see IUserInfo) and use it in the future.
     * Useful to implement remember me functionality.
     */
    void SetCookie(LPCWSTR pszCookie);

    /**
     * Set user/password without login. It will be used during upload.
     */
    void SetAuthInfo(LPCWSTR pszUserName, LPCWSTR pszPassword);

    /**
     * Start upload/transload items in separate thread.
     * You should expect that any callback will come from another thread and you should take care of thread safety.
     *
     * Parameters:
     *   pFiles           - array of UploadInfo structures. See UploadInfo.
     *   nCount           - number of items in array
     *   uploaderListener - upload listener to track upload process.
     *                      Optional, but you should know when upload complete to avoid exceptions during exit from your application.
     *                      See default template implementation UniversalUploaderListener in stubs.h
     *   progressListener - optional, progress listener to replace default progress dialog.
     *                      See default template implementation UniversalUploaderProgressListener in stubs.h
     *
     * Exceptions:
     *   If upload cannot be started then UPLOAD::UniversalUploaderException will be thrown.
     *   For example if nCount is zero.
     */
    void UploadFiles(const UploadInfo* pFiles, UINT nCount, const UploaderListenerSmartPtr &uploaderListener = UploaderListenerSmartPtr(), const ProgressListenerSmartPtr &progressListener = ProgressListenerSmartPtr());

    /**
     * Open My Images Pages in default browser.
     */
    void OpenMyImagesPage();
    /**
     * Open My Videos Pages in default browser.
     */
    void OpenMyVideosPage();
```

# Example #

> Let's create simple console application which will login and upload single image to ImageShack with default progress dialog. We need to know when upload complete to exit from application, so, we need to implement _UploaderListener_.
```
#include <atlbase.h>
#include <atlapp.h>
#include <atldlgs.h>

#include "ImageShackAPI.h"
using namespace API::ImageShack;

HANDLE gEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);

class UploaderListenerImpl : public UploaderListener
{
public:
    UploaderListenerImpl()
    {
        printf("UploaderListenerImpl::UploaderListenerImpl()\n");
    }

    ~UploaderListenerImpl()
    {
        printf("UploaderListenerImpl::~UploaderListenerImpl()\n");
    }

public: // IUploaderListenerImpl implementation
    /**
     * called before upload to have ability to cancel upload
     */
    virtual void InitWithUploader(const SmartReleasePtr<UploaderCancel> &)
    {
        printf("UploaderListenerImpl::InitWithUploader\n");
    }

    /**
     * called when all item processed
     */
    virtual void OnUploadComplete(const CSimpleArray<UploadInfo> &items, const CSimpleArray<UploadResult> &result)
    {
        printf("UploaderListenerImpl::UploadComplete\n");
        for (int i = 0; i < result.GetSize(); ++i)
        {
            UploadResult res = result[i];
            printf("file: %s\n", (CStringA)res.files.image.file);
        }
    }

    /**
     * called when user press cancel.
     * if function will return false than upload will not be cancelled.
     * if force is true than return value will be ignored
     */
    virtual bool OnUploadCancelled(bool force)
    {
        printf("UploaderListenerImpl::UploadCancelled(%s)\n", force ? "true" : "false");

        return true;
    }

    /**
     * called when current item successfully processed
     */
    virtual void OnItemComplete(const UploadInfo &item, const UploadResult &result)
    {
        printf("UploaderListenerImpl::ItemComplete(%s,%s)\n", (CStringA)item.file, (CStringA)result.files.image.file);
    }

    /**
     * called when error has been occurred on upload current item.
     */
    virtual UploaderErrorAction OnItemError(const UploadInfo &item, const UploaderErrorInfo &eiErrorInfo)
    {
        printf("UploaderListenerImpl::ItemError\n");

        CString strMessage = (CString)_T("Cannot upload file: ") + (CString)item.file + _T("\nRetry?");
        CString strTitle = _T("Upload Error...");

        int nID = MessageBox(NULL, strMessage, strTitle, MB_YESNOCANCEL|MB_ICONSTOP);
        switch(nID)
        {
        case IDYES:
            return UPLOAD::eActionRetry;
        case IDNO:
            return UPLOAD::eActionSkip;
        default:
            return UPLOAD::eActionCancel;
        }

        return UPLOAD::eActionDefault;
    }

    /**
     * called when current item was skipped
     */
    virtual void OnItemSkipped(const UploadInfo &item)
    {
        printf("UploaderListenerImpl::ItemSkipped(%s)\n", (CStringA)item.file);
    }
	
    /**
     * Called to destroy
     */
    virtual void Release()
    {
        printf("UploaderListenerImpl::Release\n");
        delete this;

        ::SetEvent(gEvent);
    }
};

void TestAPI()
{
    try
    {
        ImageShackAPI api("IA5ZRTV6fb6256ccbc3c38650bdce6e6dcfc9e55"/*Test DevKey*/);

        // trying to login
        if (!api.Login())
            printf("Upload will anonymous!\n");
        else
            printf("user cookie %s\n", (CStringA)api.GetUserInfo()->GetCookie());

        // we need file to upload
        CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST|OFN_FORCESHOWHIDDEN, _T("Images\0*.jpg;*.jpeg;*.png;*.gif;*.bmp;*.tif;*.tiff\0\0"));
        if (IDOK != dlg.DoModal())
            return;

        UploadInfo file(dlg.m_ofn.lpstrFile);

        api.UploadFiles(&file, 1, UploaderListenerSmartPtr(new UploaderListenerImpl));

        ::WaitForSingleObject( gEvent, INFINITE );

        if (api.IsLoggedIn()) api.OpenMyImagesPage();
    }
    catch (UploaderException e)
    {
        MessageBox(0, (CString)e.GetMessage(), _T("Exception"), 0);
    }
}

int _tmain(int argc, _TCHAR* argv[])
{
    CoInitialize(NULL);

    TestAPI();

    CoUninitialize();

    // close global event
    CloseHandle(gEvent);

    return 0;
}
```